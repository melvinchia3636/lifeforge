import { Icon } from '@iconify/react'

import Code from '../../components/Code'
import CustomLink from '../../components/CustomLink'
import { Alert } from "lifeforge-ui"

###### Localization

# Speaking Your Users' Language

LifeForge comes with a built-in internationalization (i18n) system that allows you to provide translations for your module's content. This means your module can speak the same language as your users, no matter where they are in the world.

<Alert className="mt-6" type="note">
  Currently, there are only 4 supported languages: English, Simplified Chinese, Traditional Chinese, and Bahasa Malaysia. A dynamic language addition system is planned for future releases.
</Alert>

<Alert className="mt-6" type="important">
  A lot of content in this section is initially generated by AI Agent (Claude Opus 4.5, state-of-the-art model as of the date of writing). All of these are then reviewed and edited by me, which hopefully removes any errors or inconsistencies. However, due to the scale and complexity of the codebase, there might still be something that I missed. If you find any, please let me know and I will add it as soon as possible.
</Alert>

---

<section id="overview">
## Overview

LifeForge uses **[i18next](https://www.i18next.com/)** with **react-i18next** for internationalization. The system features:

- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:language" className="translate-y-1" />
    **4 Supported Languages** (for now)
  </div>
  English (<code>en</code>), Simplified Chinese (<code>zh-CN</code>), Traditional Chinese (<code>zh-TW</code>), and Bahasa Malaysia (<code>ms</code>). 
- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:download" className="translate-y-1" />
    **Dynamic Loading**
  </div>
  Translations are fetched on-demand via HTTP backend, reducing initial bundle size
- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:folders" className="translate-y-1" />
    **Namespace Architecture**
  </div>
  Modular organization with <code>apps.\*</code> and <code>common.*</code> namespaces for clean separation
- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:tool" className="translate-y-1" />
    **UI-based Management**
  </div>
  Dedicated Localization Manager tool for easy editing and maintenance
- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:sparkles" className="translate-y-1" />
    **AI Translation Assistance**
  </div>
  Built-in Gemini API integration for translation suggestions in the Localization Manager tool
- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:alert-triangle" className="translate-y-1" />
    **Missing Key Reporting**
  </div>
  Automatic server-side logging of missing translation keys for easy debugging

</section>

<section id="file-organization">
## File Organization

### Module Locales (<code className='text-xl!'>apps.*</code> namespace)

Each module has its own <code>locales/</code> directory containing 4 JSON files, one for each supported language:

<Code language="plaintext">
{`apps/
└── myModule/
    └── locales/
        ├── en.json      # English (primary)
        ├── ms.json      # Bahasa Malaysia
        ├── zh-CN.json   # Simplified Chinese
        └── zh-TW.json   # Traditional Chinese`}
</Code>

### Core Locales (<code className='text-xl!'>common.*</code> namespace)

Shared translations used across the entire application are stored in the server's core locales:

<Code language="plaintext">
{`server/src/core/locales/
├── en/
│   ├── auth.json       # Authentication strings
│   ├── buttons.json    # Common button labels
│   ├── fetch.json      # Loading/fetch states
│   ├── misc.json       # Miscellaneous strings
│   ├── modals.json     # Common modal strings
│   ├── sidebar.json    # Sidebar navigation
│   └── vault.json      # Master password vault
├── ms/
├── zh-CN/
└── zh-TW/`}
</Code>

</section>

<section id="locale-file-structure">
## Locale File Structure

A well-structured locale file uses consistent key naming and logical grouping. Here's a recommended template for module locales:

<Code language="json">
{`{
    "title": "Module Name",
    "description": "Module description for ModuleHeader.",
    
    "items": {
      "entry": "Entry",
      "record": "Record"
    },
    
    "buttons": {
      "exportAsPDF": "Export as PDF"
    },
    
    "modals": {
      "entries": {
        "create": "Create Entry",
        "update": "Update Entry"
      }
    },
    
    "inputs": {
      "name": {
        "label": "Name",
        "placeholder": "Enter name..."
      },
      "description": "Description"
    },
    
    "empty": {
      "entries": {
        "title": "No Entries Found",
        "description": "Start by creating your first entry."
      }
    },
    
    "widgets": {
      "widgetName": {
        "title": "Widget Title",
        "description": "Widget description."
      }
    },
    
    "subsections": {
      "overview": "Overview",
      "settings": "Settings"
    }
}`}
</Code>

<Alert className="mt-6" type="caution">
#### Reserved Keys

There are a few keys that are reserved for specific components. These should be used as intended to ensure proper functionality:
- <code>title</code> and <code>description</code> for module metadata
- <code>empty.&lt;item&gt;.title</code> and <code>empty.&lt;item&gt;.description</code> for <code>EmptyStateScreen</code>
- <code>widgets.&lt;widgetName&gt;.title</code> and <code>widgets.&lt;widgetName&gt;.description</code> for <code>Widget</code> component
- <code>modals.&lt;modalName&gt;</code> or <code>modals.&lt;modalName&gt;.title</code> for <code>ModalHeader</code>
- <code>inputs.&lt;inputName&gt;.label</code> or <code>inputs.&lt;inputName&gt;</code> for input labels
- <code>inputs.&lt;inputName&gt;.placeholder</code> for input placeholders
- <code>buttons.&lt;buttonName&gt;</code> for button labels
- <code>items.&lt;itemName&gt;</code> for searchable item (used specifically in the <code>SearchInput</code> component)
</Alert>

### Common Buttons Reference

Rather than defining common button labels in every module, you can use the shared <code>common.buttons</code> namespace. Here are some commonly available keys:

| Key | English |
|-----|---------|
| <code>create</code> | Create |
| <code>update</code> | Update |
| <code>cancel</code> | Cancel |
| <code>delete</code> | Delete |
| <code>save</code> | Save |
| <code>new</code> | New \{\{item\}\} |
| <code>submit</code> | Submit |
| <code>confirm</code> | Confirm |

By default, the <code>namespace</code> prop in lifeforge-ui button components points to <code>common.buttons</code>, so you can directly use these keys without explicitly specifying the namespace. For example,

<Code language="tsx">
{`<Button>
    create  {/* The localized text will be automatically looked up from common.buttons.create */}
</Button>`}
</Code>

<Alert className="mt-6" type="tip">
  These are just a few examples. You can find the full list of available keys in the locale file in the codebase.
</Alert>

</section>

<section id="usage-patterns">
## Usage Patterns

### Basic Component Usage

The most straightforward way to use translations is with the <code>useTranslation</code> hook:

<Code language="tsx">
{`import { useTranslation } from 'react-i18next'

function MyComponent() {
    // Load module-specific translations
    const { t } = useTranslation('apps.myModule')

    return (
      <div>
        <h1>{t('title')}</h1>
        <p>{t('description')}</p>
      </div>
    )
}`}
</Code>

### Multiple Namespaces

When you need translations from multiple namespaces, pass an array to <code>useTranslation</code>:

<Code language="tsx">
{`function MyComponent() {
    const { t } = useTranslation(['apps.myModule', 'apps.anotherModule'])
    
    return (
      <>
        <h1>{t('apps.myModule:title')}</h1>
        <p>{t('apps.anotherModule:someText')}</p>
      </>
    )
}`}
</Code>

### Interpolation

For dynamic content, use interpolation with double curly braces in your locale files:

<Code language="tsx">
{`// In locale file: "greeting": "Hello, {{name}}!"
t('greeting', { name: 'John' }) // → "Hello, John!"`}
</Code>

A few components in lifeforge-ui have a <code>tProps</code> prop that allows you to pass translation props to the component.

<Code language="tsx">
{`<Button tProps={{ item: t('items.entry') }}>
    new  {/* -> New Entry */}
</Button>
`}
</Code>

</section>

<section id="lifeforge-ui-integration">
## lifeforge-ui Integration

Many components in <code>lifeforge-ui</code> have built-in translation support via the <code>namespace</code> prop. This allows for cleaner code by automating translation lookups. However, different components may have different translation props, so refer to the Storybook documentation for [lifeforge-ui](https://ui.lifeforge.dev/) for more information.

</section>

<section id="adding-translations-to-your-module">
## Adding Translations to Your Module

When using <code>ForgeCLI</code> to create a module, locale files are automatically generated for you with a basic structure. If you have an OpenAI API key configured in your API Key Vault, the CLI will even auto-translate your module name and description into all supported languages!

</section>

<section id="localization-manager">
## Localization Manager

LifeForge includes a dedicated web-based **Localization Manager** tool for managing translations across your entire application:

- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:binary-tree" className="translate-y-1" />
    **Visual Tree Editor**
  </div>
  Navigate and edit locale keys in a hierarchical tree structure
- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:columns" className="translate-y-1" />
    **Side-by-Side Editing**
  </div>
  Edit translations for all languages simultaneously
- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:sparkles" className="translate-y-1" />
    **AI Translation Suggestions**
  </div>
  Get translation suggestions powered by Gemini API
- <div className="text-bg-800 dark:text-bg-100 flex items-center gap-2">
    <Icon icon="tabler:search" className="translate-y-1" />
    **Search Functionality**
  </div>
  Quickly find keys across all namespaces

The Localization Manager is accessible via SSO from the main application and is located in the <code>tools/localizationManager</code> directory.

</section>

<section id="best-practices">
## Best Practices

### 1. Consistent Key Naming

Use <code>camelCase</code> for keys and organize them by type:

<Code language="json">
{`{
    "buttons": { "exportToCSV": "Export to CSV" },
    "modals": { "confirmDelete": "Confirm Delete" },
    "inputs": { "entryName": { "label": "Entry Name", "placeholder": "Enter name..." } }
}`}
</Code>

### 2. Use Interpolation for Dynamic Content

Interpolation is an <code>i18next</code> built-in feature that allows you to insert dynamic values into your translations. This is useful for dynamic content that changes based on user input or other factors.

<Code language="json">
{`{
    "messages": {
      "deleteConfirm": "Are you sure you want to delete {{name}}?",
      "itemCount": "{{count}} item(s) found"
    }
}`}
</Code>

### 3. Provide Context with Nested Keys

Nested keys allow you to group related translations together and make it easier to find and manage them.

<Code language="json">
{`{
  "empty": {
    "entries": {
      "title": "No Entries",
      "description": "Create your first entry to get started."
    }
  }
}`}
</Code>

### 4. Leverage lifeforge-ui's Namespace Prop

Instead of manual <code>t()</code> calls, use the <code>namespace</code> prop on lifeforge-ui components whenever possible. Refer to the [lifeforge-ui](https://ui.lifeforge.dev/) documentation for explanation and examples on how to use each component.

<Code language="tsx">
{`// ✅ Good - automatic lookup
<Button namespace="apps.myModule">saveEntry</Button>

// ❌ Verbose - manual translation
<Button>{t('buttons.saveEntry')}</Button>`}
</Code>

### 5. Do not Reinvent the Wheel

When defining a new key, check if it already exists in the core locales. If it does, use the existing key instead of creating a new one.

<Code language="json">
{`{
    "buttons": {
      "newEntry": "New Entry" // ❌ Bad - it is already defined in core locales
      "exportToCSV": "Export to CSV" // ✅ OK - it is module specific
    }
}`}
</Code>

### 6. Keep Translations in Sync

When adding a key to English, immediately add placeholder or translated values to all other language files to prevent missing key warnings.

</section>

<section id="troubleshooting">
## Troubleshooting

### Missing Translation Warnings

Check server logs for "Missing locale" warnings. The i18n system automatically reports missing keys:

<Code language="plaintext">
{`Missing locale apps.myModule:buttons.newButton`}
</Code>

### Translation Not Updating

- Refresh the page
- Clear browser cache
- Restart the dev server
- Verify the key is correctly added to all language files
- Verify the namespace is correctly specified
- Verify the key is correctly referenced in the code

### Namespace Not Found

Ensure that:
- The module is properly registered
- The <code>locales/</code> directory exists at the correct path within your module
- The JSON files are valid and properly formatted

<Alert type="tip" className="mt-6">
Sometimes you'll face an issue where the locales for the entire system are not properly loaded. This is usually caused by a syntax error in one of the many JSON files. Check the files that you have recently modified for any syntax errors.

Another reason might be the version mismatch of the <code>i18next</code> and the <code>react-i18next</code> packages. Ensure that all the client codebase and all your modules are using the same version of these packages.
</Alert>

</section>
